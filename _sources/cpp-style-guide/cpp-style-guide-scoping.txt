

--------------------------------------------------------------------------------
Локальные определения
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
Минимизируйте область видимости переменных
--------------------------------------------------------------------------------
Опреляйте и сразу инициализируйте переменные в максимально узкой области 
видимости как можно "ближе" к первому месту использования. Это помогает 
читателю найти это определение, разобраться какого типа переменная и какое 
у нее начальное значение, ознакомится с комментарием (при наличии).

.. note:: Определение переменных в начале функции является признаком 
   использования примера на языке C (а не C++).

.. hint::

   .. code-block:: c++

    int i(f()); // определение с инициализацией

.. error::

   .. code-block:: c++

    int i;   // неинициализированная переменная!
    i = f();

Помните о возможности использования списков инициализации.

.. hint::

   .. code-block:: c++

      std::vector<int> v{1, 2};

.. error::

   .. code-block:: c++
      
      std::vector<int> v;
      v.push_back(1);
      v.push_back(2);

.. note:: Использование методов типа push_back или поэлементное присвоние 
   значений часто является признаком использования примеров с использование 
   устаревшего стандарта языка.

Если у структуры нет умолчательного конструктора (планируется использование 
в виде POD) и нет инициализвции членов в опредлении типа, то при определении 
переменной необхоимо использовать инициализирующий список.

.. hint::

   .. code-block:: c++

      DataInStruct s{0};

.. error::

   .. code-block:: c++
      
      DataInStruct s;

Используемые в инструкциях циклов и ветвлений переменные в большинстве случаев 
могут быть определены внутри этих инструкций.

.. hint::

   .. code-block:: c++

      while (const char* p(strchr(str, '/')) {
        str = p + 1;
      }

Исключением является обоснованное соображениями производительности вынесение из 
"длинных" циклов определения объектов, которые могут быть повторно использованы 
в теле цикла. Это позволяет избежать вызова конструктора и деструктора на 
каждой итерации такого цикла.

.. warning::
   
   Неэффективная реализация

   .. code-block:: c++
      
      for (int i(0); i < 1000000; i += 1) {
        Foo f; // ctor и dtor вызываются 1000000 раз
        f.DoSomething(i);
      }

.. hint::

   .. code-block:: c++

      Foo worker; // My ctor and dtor get called once each.
      for (int i(0); i < 1000000; i +=1 ) {
        worker.DoSomething(i);
      }

